使用者定義輸出
---

「使用者定義輸出」（User Defined Outputs，簡稱 UDOs）允許使用者透過IronPython腳本來定義後處理計算。這些UDO腳本需要放置於「UserDefinedOutputs」目錄下，該目錄可以位於syslib、userlib或Personallib下，並可依需求組織不同的目錄結構。「Lib」目錄名稱具有特殊用途，詳細用途將在文件後續部分說明。

當UDO腳本被放置在syslib/UserDefinedOutputs、userlib/UserDefinedOutputs或Personallib/UserDefinedOutputs後，使用者就可以在AEDT當中通過「結果>創建使用者定義解決方案」菜單來創建「使用者定義解決方案」。

使用「結果>創建使用者定義解決方案>更新菜單」來刷新菜單，以包括可能已被複製到syslib、userlib或Personallib的新UDO腳本，或者從菜單中移除已被刪除的腳本。一旦創建了使用者定義解決方案，由UDO定義的解決方案和計算將在報告器中可用，如同其他量度一樣，並在新的「使用者定義」報告類型中顯示。

![2024-08-24_17-22-12](/assets/2024-08-24_17-22-12.png)

![2024-08-24_17-13-05](/assets/2024-08-24_17-13-05.png)

![2024-08-24_17-14-28](/assets/2024-08-24_17-14-28.png)


### 使用者定義輸出優缺點
使用者定義輸出（UDO）在AEDT中的應用有其優缺點：

#### 優點： 
 
1. **直接整合顯示** ：使用UDO可以讓使用者直接在AEDT的圖表中查看結果，這增加了工作流程的整合性和即時性，使得數據分析和結果展示更為高效。
 
2. **高度自定義** ：UDO提供了高度的自定義能力，使用者可以根據特定的需求計算和顯示數據，這對於複雜的工程分析尤為重要。
 
3. **靈活的擴展性** ：由於可以使用任何.NET語言編寫，這使得UDO具有強大的擴展性和適應性，適用於多樣化的工程需求。

#### 缺點： 
 
1. **學習曲線陡峭** ：對於初學者而言，使用IronPython語言進行類別撰寫可能相對困難，需要一定的程式設計背景和對AEDT架構的瞭解。
 
2. **調試困難** ：UDO的調試過程可能比較複雜，尤其是在大型或複雜的腳本中，錯誤追蹤和性能優化可能成為挑戰。

總的來說，UDO在提供強大功能和靈活性的同時，也帶來了較高的入門門檻和維護需求。這需要使用者在使用前評估自己的技術能力和項目需求，適當選擇使用UDO或尋找其他可能的解決方案。

### 類別框架
這個範例代碼展示了如何在AEDT中使用.NET API來擴展使用者定義輸出（UDO），具體實現了一個計算天線方位角（Angle of Arrival, AOA）的UDO擴展。下面是這個類別框架的簡單介紹：

#### 導入模塊 
 
- **API 和數據接口** : 使用 `Ansys.Ansoft.ModulePluginDotNet` 名稱空間，這些模塊提供了必要的API和數據結構來訪問和操作AEDT的內部數據。
 
- **數學模塊** : 使用標準的 `math` 模塊來計算數學表達式，特別是使用 `pi`。
 
- **日誌記錄** : 通過 `logging` 模塊記錄操作過程，以便於追蹤和調試。
`UDOExtension` 類這個類繼承自 `IUDOPluginExtension`，定義了UDO的多個基本操作和數據流處理方法： 
- **初始化和描述** : 通過 `__init__`, `GetUDSName`, 和 `GetUDSDescription` 方法初始化UDO擴展並提供基本描述。
 
- **定義輸入和輸出** : `GetInputUDSParams` 方法設置輸入參數，`GetDynamicProbes` 處理動態探測器的設置。
 
- **量度類別和計算** : `GetCategoryNames`, `GetQuantityNames`, 和 `GetQuantityInfo` 定義量度類別和相關信息。`Compute` 方法則是核心，負責處理計算邏輯和數據輸出。

#### 主要計算邏輯 
 
- **數據提取** : 從輸入數據中提取特定頻率的數據點。
 
- **角度換算** : 將角度從弧度轉換為度。
 
- **補償計算** : 透過 `compensate` 函數處理角度超出正常範圍的情況。

#### 日誌記錄 
在關鍵的操作節點記錄調試信息，包括初始化、數據讀取和處理等，有助於開發和維護過程中的問題追蹤和性能評估。

### 範例碼
```python
from Ansys.Ansoft.ModulePluginDotNet.Common.API import *
from Ansys.Ansoft.ModulePluginDotNet.Common.API.Interfaces import *
from Ansys.Ansoft.ModulePluginDotNet.UDO.API.Interfaces import * 
from Ansys.Ansoft.ModulePluginDotNet.UDO.API.Data import *
from math import pi

import logging
logging.basicConfig(filename='AOA.log', level=logging.DEBUG, filemode='a')
logging.debug('start')

def compensate(x):
    if x < -180:
        return float(x + 360)
    elif x > 180:
        return float(x - 360)
    else:
        return float(x)

class UDOExtension(IUDOPluginExtension):
    def __init__(self):
        logging.debug('__init__')

    
    def GetUDSName(self):
        logging.debug('GetUDSName')
        return "AOA Calculation"
    
    def GetUDSDescription(self):
        logging.debug('GetUDSDescription')
        return "User Defined Solution: AOA"


    
    def GetInputUDSParams(self, udsParams, propertyList, userSelectedDynamicProbes):
        logging.debug('GetInputUDSParams')   
        p1 = UDSProbeParams('probe1',
                            '',
                            Constants.kDoubleParamStr,
                            "Terminal Solution Data",
                            'ang_deg(St(s1,s5))')
        p2 = UDSProbeParams('probe2',
                            '',
                            Constants.kDoubleParamStr,
                            "Terminal Solution Data",
                            'ang_deg(St(s2,s5))')
        p3 = UDSProbeParams('probe3',
                            '',
                            Constants.kDoubleParamStr,
                            "Terminal Solution Data",
                            'ang_deg(St(s3,s5))')
        p4 = UDSProbeParams('probe4',
                            '',
                            Constants.kDoubleParamStr,
                            "Terminal Solution Data",
                            'ang_deg(St(s4,s5))')
        udsParams.Add(p1)
        udsParams.Add(p2)
        udsParams.Add(p3)
        udsParams.Add(p4)

        prop = propertyList.AddNumberProperty('fcal', '1e9')
        prop.Description = 'calculation frequency'

        return True

    def GetDynamicProbes(self, probes):
        logging.debug('GetDynamicProbes')

    def GetCategoryNames(self):  
        logging.debug('GetCategoryNames')           
        return ['AOA']
    
    def GetQuantityNames(self, category):
        logging.debug('GetQuantityNames')  
        return ['b1_b4', 'b2_b1', 'b3_b2', 'b4_b3']

    def GetQuantityInfo(self, qtyName):
        return QuantityInfo(Constants.kDoubleParamStr)


    def GetUDSSweepNames(self):
        logging.debug('GetUDSSweepNames')        
        return ['Tx_Ang']


    def Compute(self, inData, outData, params, progressMonitor):
        logging.debug('Compute')
        
        freqs = inData.GetSweepsDataForProbe('probe1', 'Freq')
        fcal = params.GetNumberProperty('fcal').ValueSI
        n = list(freqs).index(fcal)
        logging.debug((fcal, n))
        
        theDict = inData.GetVariableValues()
        
        key = list(theDict.Keys)[0]
        value = float(list(theDict.Values)[0].replace('deg', ''))
        logging.debug((key, value))
        
        x1 = inData.GetDoubleProbeData('probe1')[n]*360/2/pi
        x2 = inData.GetDoubleProbeData('probe2')[n]*360/2/pi
        x3 = inData.GetDoubleProbeData('probe3')[n]*360/2/pi
        x4 = inData.GetDoubleProbeData('probe4')[n]*360/2/pi
        

        logging.debug('output')
        outData.SetSweepsData("Tx_Ang", [value*2*pi/360])
        outData.SetDoubleQuantityData("b1_b4", [compensate(x1-x4)])
        outData.SetDoubleQuantityData("b2_b1", [compensate(x2-x1)])
        outData.SetDoubleQuantityData("b3_b2", [compensate(x3-x2)])
        outData.SetDoubleQuantityData("b4_b3", [compensate(x4-x3)])
        return True
```

### 參考
HFSS.pdf當中可以找到相關API

![2024-08-24_17-24-16](/assets/2024-08-24_17-24-16.png)