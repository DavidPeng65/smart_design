當工程智慧遇上人工智慧的耦合困境
---

**場景：** 一間明亮的現代會議室，白板上還留有上次會議模糊的架構圖痕跡。大片的落地窗外是井然有序的科技園區，但窗內的氣氛卻有些凝重。

**人物：**
* **Alex：** 一位充滿熱情、技術精湛的自動化工程師。他對訊號完整性（SI）領域的工程知識（Know-how）瞭若指掌，並且熟練掌握了用Python控制ANSYS電子設計軟體的核心工具——PyEDB與PyAEDT。
* **Mr. Lin：** ANSYS資深自動化專家，擁有超過十五年的CAE/EDA自動化流程開發經驗。他的眼神深邃，透露出對複雜系統架構的深刻理解。

**故事開始**

下午兩點，Alex提前走進了會議室。他打開筆記型電腦，螢幕上是密密麻麻的程式碼，一個基於PySide6開發的桌面應用程式。這本該是他引以為傲的作品，一個旨在將複雜的SI分析流程自動化的宏大專案。然而此刻，他臉上的表情卻是疲憊與困惑交織。

這個專案的初衷是革命性的。過去，SI工程師需要手動操作ANSYS Electronics Desktop (AEDT)，進行繁瑣的模型匯入、材料設定、疊構調整、埠指派、模擬參數設定、執行分析，最後再手動導出數據、繪製圖表。整個過程耗時耗力，且極易出錯。Alex的目標是將這一切封裝在一個友善的圖形化使用者介面（GUI）背後，讓使用者只需點擊幾下按鈕，就能完成從設計檔到分析報告的全過程。

為了加速開發，Alex引入了時下最熱門的AI Agent作為他的開發夥伴。他深知自己的長處在於工程領域的專業知識和PyAEDT/PyEDB的應用，而對於GUI設計、前端框架、數據視覺化等領域，AI無疑是更高效的專家。

專案初期，這種人機協作的模式堪稱完美。Alex會用精簡的程式碼片段（Snippet）向AI Agent展示如何實現一個特定的工程任務，例如：「這是一段使用PyEDB讀取.brd檔案並設定銅箔厚度的程式碼。」或者「用這段PyAEDT程式碼來建立一個暫態分析的Setup。」

AI Agent的表現令人驚豔。它能迅速理解Alex的意圖，並將這些工程程式碼無縫地整合到PySide6的框架中，快速生成精美的GUI介面、互動式表格和動態的數據圖表。一個按鈕、一個輸入框背後，都由AI巧妙地編織了Alex提供的工程邏輯。短短幾週，專案的原型就已初具規模，功能看起來十分完整。

然而，當專案的程式碼量突破一千行時，災難悄然而至。

「耦合」，這個軟體工程領域的幽靈，開始在專案的每個角落徘徊。

問題源於一次看似簡單的需求變更。技術經理希望在設定埠的介面中，增加一個「差分對自動配對」的功能，並允許使用者手動微調配對結果。Alex將這個需求轉化為具體的PyEDB邏輯，並將範例程式碼交給了AI Agent。

AI Agent接收了指令，開始修改程式碼。但這次，它似乎陷入了困境。由於GUI的介面邏輯（例如，使用者點擊按鈕的反應）與底層的PyEDB操作（例如，遍歷Net、尋找匹配的埠）被緊密地編寫在一起，AI在嘗試加入新功能時，必須同時理解UI事件循環和複雜的EDB物件模型。修改的結果是一場災難——新功能沒有正確實現，反而破壞了原有的手動設定埠功能。無論Alex如何調整他的提示（Prompt），AI產出的程式碼總是在修好一個問題的同時，引發另外新的問題。

Alex被迫親自下場修改。他花了整整兩天才理清那一段由AI編織、混雜了Qt信號與槽機制以及PyEDB API呼叫的程式碼。他發現，`QPushButton`的`clicked`信號，直接觸發了一個包含上百行PyEDB操作的函式。這個函式不僅處理UI元素的更新，還直接操控著底層的設計資料庫。這意味著，任何UI上的小改動，都可能直接衝擊到核心的工程邏輯，反之亦然。

「這就像是把引擎直接焊在了車殼上，」Alex對自己苦笑道，「想換個火星塞，結果得把整個車門拆下來。」

他意識到，這個專案已經變成了一個「巨石應用」（Monolithic Application），僵硬、脆弱，難以維護。就算是能力強大的AI Agent，面對這樣一個內部結構混亂的龐然大物，也束手無策。

這時，Mr. Lin推門走了進來。他看到Alex鎖著眉頭，電腦螢幕上是令人眼花撩亂的程式碼，便微笑著問道：「Alex，看來你遇到了一些挑戰？」

Alex如釋重負，他將過去幾週的困境一五一十地向Mr. Lin娓娓道來，從最初與AI協作的喜悅，到如今深陷泥潭的痛苦。「Mr. Lin，我知道問題出在哪裡，是『高耦合』。但我不知道該如何解決。AI Agent非常擅長它份內的事，比如用PySide建立一個漂亮的表格，或者用Plotly繪製互動式圖表。但它不懂ANSYS，不懂PyEDB的複雜性。我把工程程式碼餵給它，它就像一個盡責的秘書，把它們原封不動地貼到了GUI框架的各個角落。結果，我們創造了一個看似強大，實則難以維護的怪物。」

Mr. Lin靜靜地聽著，不時點頭。待Alex說完，他走到白板前，拿起一支記號筆。

「Alex，你遇到的問題非常典型，」Mr. Lin的聲音沉穩而有力，「這不是AI的錯，也不是你的錯。這是一個架構設計問題。你們的分工模式聽起來是：『工程師負責核心邏輯，AI負責整合與呈現』。但問題的關鍵在於，你們對『整合』的定義出現了偏差。」

他在白板上畫了兩個大方塊。一個標註為「工程師 (Alex)」，另一個標註為「AI Agent」。

「AI Agent的核心能力是理解通用軟體框架、API和數據結構。你給它PySide，它能寫出優雅的GUI；你給它Pandas DataFrame，它能變出五花八門的圖表。而你的核心能力，是訊號完整性的領域知識，以及如何將這些知識轉化為PyEDB和PyAEDT的具體操作指令。你們各自在自己的領域都是專家。」

Mr. Lin接著說：「當AI直接將你的PyEDB程式碼嵌入到GUI事件處理函式中時，它實際上是在執行一個它並不真正理解的任務。它不知道`edb.core.nets.Net`這個物件的生命週期，也不明白為什麼某個API呼叫必須在另一個之前執行。它只是在做一個『字串拼接』和『語法縫合』的工作。這就導致了你所說的，GUI的程式碼中，遍布著PyEDB和PyAEDT的『膏藥』，讓整個系統變得僵硬。」

Alex深有同感地點了點頭。

「解決方案的核心思想只有一個詞：**去耦合（Decoupling）**。」Mr. Lin在兩個方塊之間畫了一條清晰的界線。「我們需要建立一個明確的邊界，讓工程師和AI都能在各自最擅長的領域內獨立工作，並透過一個定義良好的『契約』來溝通。」

他開始在白板上勾勒出一個新的架構。

「首先，徹底分離工程邏輯。你，作為工程師，應該忘掉GUI的存在。你的任務是開發一系列獨立的、可執行的Python腳本（.py檔案）。每一個腳本都只做一件定義明確的事情。」

Mr. Lin在「工程師」的方塊下，畫出了一個個小小的`.py`檔案圖示：

* `import_design.py`
* `set_stackup.py`
* `assign_materials.py`
* `set_ports.py`
* `create_hfss_setup.py`
* `run_simulation.py`
* `export_sparam.py`
* `get_layer_info.py`

「你看，」他指著這些檔案，「每一個都是一個獨立的工具。例如，`set_stackup.py`這個腳本，它的職責就是讀取一個設計檔的路徑和一個包含疊構資訊的JSON檔案，然後執行設定疊構的操作。它不需要知道是誰呼叫了它，是使用者點擊了按鈕，還是一個自動化的CI/CD流程。它的介面非常清晰：**透過命令列參數（Arguments）接收輸入，透過標準輸出（stdout）或生成檔案（例如JSON）來提供結果。**」

Mr. Lin繼續闡述：「這些腳本是純粹的PyAEDT/PyEDB程式碼。你可以為它們編寫單獨的單元測試，確保`set_ports.py`在任何情況下都能正確地設定埠，而無需啟動整個龐大的GUI應用。這讓你的開發和除錯工作變得極其高效。」

Alex的眼睛亮了起來，他彷彿看到了一條清晰的道路。「我明白了，我專注於打造一個個穩定可靠的『命令行工具集』。那AI Agent呢？它如何使用這些工具？」

「這正是這個架構的優雅之處，」Mr. Lin笑著說。「AI Agent的角色從一個『整合者』轉變為一個『指揮官』。它的任務是建立GUI，並在使用者進行操作時，去『呼叫』你寫好的這些獨立腳本。」

他在「AI Agent」的方塊下寫下了幾個關鍵字：`subprocess.Popen`和`PySide6.QProcess`。

「當使用者在GUI上填寫好疊構資訊，點擊『設定疊構』按鈕時，GUI程式不再是直接執行一大段PyEDB程式碼。取而代之的，它會執行一個類似這樣的命令：`python set_stackup.py --input_file /path/to/design.aedb --stackup_json /path/to/stackup.json`。」

「GUI透過`subprocess.Popen`或PySide6中功能更強大的`QProcess`來啟動這個外部程序。`QProcess`的優點在於，它可以非同步執行，並且能夠即時捕獲外部腳本的標準輸出和標準錯誤。這意味著，你的`set_stackup.py`在執行過程中，可以透過`print()`函式輸出進度資訊，比如『正在讀取疊構檔案...』、『正在設定第3層...』、『疊構設定完成』。這些訊息可以被GUI即時捕捉，並顯示在介面的狀態列或日誌視窗中，為使用者提供極佳的互動體驗。」

Alex恍然大悟：「所以，GUI和工程邏輯之間的溝通，不再是函式呼叫，而是程序間的通訊！輸入是命令列參數，輸出是腳本的執行結果和日誌。AI Agent完全不需要理解PyEDB的任何細節，它只需要知道如何構建正確的命令列，以及如何解析腳本回傳的JSON結果就夠了。」

「完全正確！」Mr. Lin讚許地說。「資料視覺化也是同理。你的`run_simulation.py`執行完畢後，會生成一個S參數檔案。接著，GUI會呼叫另一個你寫的`process_data.py`，這個腳本讀取S參數，計算出TDR、插入損耗等關鍵指標，並將結果整理成一個結構化的JSON檔案。最後，AI Agent讀取這個JSON，利用它擅長的Matplotlib或Plotly庫，將數據繪製成漂亮的圖表。整個流程中，AI始終在處理它最熟悉的數據結構，而不是複雜的工程物件。」

Mr. Lin在白板的最後，畫上了一個所有開發者都熟悉的圖示——GitHub的章魚貓。

「最後，也是最重要的一點，這種架構與版本控制系統（如Git）是天作之合。你可以建立兩個主要的資料夾：`/scripts`和`/app`。你，Alex，在`/scripts`目錄下工作，專心打磨你的工程腳本。AI Agent則在`/app`目錄下修改GUI。你們的職責範圍清晰，程式碼互不干擾。」

「想像一下，如果AI Agent在某次更新中弄壞了GUI的佈局。在過去的耦合架構中，你可能不敢輕易回滾，因為GUI程式碼裡混雜著你剛剛加入的關鍵工程邏輯。但在新架構下，這變得無比簡單。你只需要在Git中`discard changes`或`git checkout`恢復`/app`目錄的程式碼即可，你的`/scripts`目錄下的核心工程邏輯絲毫不會受到影響。你可以大膽地為新功能建立分支（Branching），讓AI在一個分支上嘗試新的UI設計，而你在主幹上繼續優化演算法。這種開發模式，才是真正的大幅加速。」

會議室裡一片寂靜，只剩下Mr. Lin筆下標記的線條在白板上延伸。Alex的思緒跟隨著這些線條，一個清晰、健壯、可擴展的系統藍圖在他腦海中逐漸成形。過去幾週的迷霧被徹底吹散，取而代之的是一種前所未有的清晰和篤定。

他終於明白，與AI協作的最高境界，不是讓AI模仿工程師的工作，也不是讓工程師去適應AI的邏輯，而是要像設計一個精密系統一樣，為兩者定義清晰的介面和職責邊界。讓工程師的智慧專注於解決複雜的工程問題，產出穩定可靠的「工具」；讓人工智慧的強大能力專注於建構使用者體驗和數據呈現，成為這些工具的「使用者」和「指揮官」。

「Mr. Lin，太感謝您了。」Alex的聲音中充滿了由衷的感激和興奮，「您不僅給了我解決方案，更重要的是，您給了我一套與AI進行大規模專案協作的正確思維框架。去耦合、命令行介面、程序間通訊、版本控制……這些看似傳統的軟體工程原則，在AI時代，不僅沒有過時，反而變得更加至關重要。」

Mr. Lin微笑著放下筆：「正是如此。AI是一個無比強大的工具，但工具越強大，我們越需要一個穩固的架構來駕馭它。祝你的專案順利，Alex。」

會議結束了。Alex走回自己的座位，他看著螢幕上那個龐大而混亂的專案，不再感到沮喪。他知道，接下來的工作將是艱鉅的重構，但他心中充滿了信心。他要做的第一件事，就是建立一個新的專案目錄，裡面只有兩個子目錄：`/scripts`和`/app`。

窗外的陽光灑進辦公室，為嶄新的一天拉開了序幕。這一次，Alex知道，他和他的AI Agent，正走在一條通往成功的康莊大道上。

![](/assets/2025-10-14_15-26-44.png)