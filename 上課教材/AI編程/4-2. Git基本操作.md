## 4b. Git基本操作

你是否曾經經歷過這樣的場景？

你的期末報告、畢業論文或是一個重要的專案檔案，在你的電腦裡呈現出這樣的狀態：

- `報告_初版.docx`
- `報告_修改後.docx`
- `報告_給老師的版本.docx`
- `報告_v2.docx`
- `報告_最終版.docx`
- `報告_最終版_真的最終了.docx`
- `報告_最終版_打死不改了.docx`

又或者，你和幾個朋友一起合作一個專案，你們用 Email 或雲端硬碟互相傳送檔案。不久後，混亂就開始了：你不知道誰的版本才是最新的，你不小心覆蓋了隊友辛苦工作的成果，或者你想找回三天前被刪除的一段重要文字，卻發現早已石沉大海。

如果你對這些場景感到心有戚戚焉，那麼恭喜你，你已經體會到了所有開發者、設計師、作家，甚至任何需要處理數位文件的人都會遇到的核心痛點：**版本控制的混亂**。

而 Git，就是終結這一切混亂的終極神器。

這篇文章不會一開始就丟給你一堆複雜的指令。相反，我們將建立一個堅實的觀念模型，讓你從根本上理解 Git 是什麼、它如何運作，以及它為何如此強大。當你理解了「為什麼」之後，學習「如何做」將會變得輕而易舉。


### **第一部分：核心觀念 —— 什麼是版本控制？**

在我們談論 Git 之前，讓我們先聊聊「版本控制」（Version Control）這個概念。

想像一下，你正在寫一部小說。

**沒有版本控制的情況：**
你寫了第一章，存檔為 `小說.txt`。第二天，你修改了第一章，又寫了第二章，你再次存檔，覆蓋了昨天的版本。一週後，你覺得第一章的舊版開頭其實比較好，但它已經被你覆蓋，永遠消失了。這就是沒有版本控制的窘境——**你的歷史是一條無法回頭的單行道**。

**手動版本控制：**
這就是我們前面提到的 `報告_最終版_真的最終了.docx` 的方法。你每次要進行大修改前，就複製一份檔案，重新命名。這稍微好一些，你至少保留了歷史紀錄。但缺點顯而易見：
1.  **檔案混亂**：檔名變得毫無意義，資料夾變得臃腫不堪。
2.  **難以比較**：你想知道 `v2` 和 `v3` 到底改了哪裡？你只能打開兩個檔案，用肉眼一行一行比對。
3.  **協作困難**：如果你的朋友也要修改，你們就得協調誰先改，改完再傳給你，然後你再合併，過程極其痛苦且容易出錯。

**版本控制系統（Version Control System, VCS）：**
現在，想像你有一個神奇的筆記本。每當你完成一個段落或章節，你就對著筆記本說：「幫我記錄這個版本，標題是『完成第一章草稿』。」
筆記本就會拍下一張「快照」（Snapshot），記下當前所有文字的狀態，並貼上你給的標籤。

第二天，你修改了文字，然後又說：「記錄這個版本，標題是『修改主角對話，新增第二章』。」筆記本又拍下一張快照。

這本神奇的筆記本就是一個版本控制系統。它帶來了幾個革命性的好處：
-   **時光機**：你可以隨時翻閱筆記本，回到任何一個你記錄過的「快照」，查看當時的內容，甚至可以從那個時間點重新開始。
-   **清晰的歷史紀錄**：你的所有修改都有明確的標籤（我們稱之為「提交訊息」），你可以清楚地看到每一次變更的目的。
-   **差異比較**：你可以輕鬆地讓筆記本告訴你，『修改主角對話』這個版本和『完成第一章草稿』這個版本之間，到底哪幾個字、哪幾行被修改了。

**Git 就是目前全世界最強大、最流行的那本「神奇筆記本」。** 它是一個「分散式版本控制系統」，但我們先別管「分散式」這個詞，我們先專注於它在你個人電腦上能做些什麼。


### **第二部分：Git 的三大空間 —— 建立你的本地宇宙**

要理解 Git 的日常操作，你必須先理解一個最重要的核心觀念：**Git 的三大空間**。這是初學者最容易混淆的地方，但一旦搞懂，後面就一帆風順。

想像你的專案開發過程就像在準備一場重要的展覽。

1.  **工作目錄 (Working Directory)**
    -   **這是什麼？** 就是你在電腦上實際看到和編輯的專案資料夾。裡面有你的程式碼、圖片、文件等所有檔案。
    -   **比喻：你的工作室。** 這是你所有創作發生的地方。你可以在這裡新增檔案（畫新畫）、修改檔案（修改畫作）、刪除檔案（撕掉畫作）。這裡的一切都是混亂、未完成、隨時可能變動的。

2.  **暫存區 (Staging Area / Index)**
    -   **這是什麼？** 這是 Git 獨有的一個重要區域。它是一個虛擬的空間，用來「暫存」你希望在下一個版本快照中包含的變更。
    -   **比喻：展覽的待展區。** 在你的工作室裡，你可能同時在畫三幅畫，修改兩份文件，但你這次只想把「完成的A畫」和「修改好的B文件說明」放到下一個展覽批次中。於是，你把這兩樣東西從工作室搬到了「待展區」。待展區裡的東西是你精心挑選、準備好要正式記錄下來的。你工作室裡的其他東西，比如那幅還沒畫完的C畫，就還留在工作室，不會進入這次的展覽。
    -   **為什麼需要這個區域？** 它給了你極大的彈性。你可以將一個檔案中的多次修改分批提交。例如，你的一個檔案裡，同時修復了一個 bug，又增加了一個新功能。你可以先只把「修復 bug」的相關程式碼加入暫存區，做一次提交，寫下訊息「修復了XXX bug」；然後再把「增加新功能」的程式碼加入暫存區，做第二次提交，訊息是「增加了XXX功能」。這讓你的版本歷史變得極其乾淨、有條理。

3.  **本地儲存庫 (Local Repository / .git directory)**
    -   **這是什麼？** 這是 Git 儲存所有版本快照的地方。當你初始化一個 Git 專案時，它會在你的專案資料夾下建立一個隱藏的 `.git` 資料夾，這就是你的本地儲存庫。
    -   **比喻：展覽的永久檔案室。** 當你對「待展區」裡的東西都感到滿意後，你一聲令下，工作人員就會把待展區裡的所有東西打包成一個箱子，貼上標籤（例如「2025年夏季展覽 - 第一批展品」），然後永久地存放到檔案室裡。這個箱子就是一次「提交」（Commit），裡面的內容就是一個完整的專案快照。檔案室裡的箱子按照時間順序排列，構成了你專案的完整歷史。

**總結一下這個流程：**

1.  你在 **工作目錄**（工作室）裡修改檔案。
2.  你將想要提交的修改，使用 `git add` 指令，放入 **暫存區**（待展區）。
3.  你使用 `git commit` 指令，將暫存區裡的所有內容打包成一個快照，永久存入 **本地儲存庫**（檔案室）。

這個「**修改 -> 暫存 -> 提交**」的循環，就是你在 Git 上的核心日常工作流程。

#### **基礎指令與三大空間的對應**

-   `git init`：在你的專案資料夾裡建立一個新的 `.git` 資料夾。**（建立一個新的檔案室）**
-   `git status`：檢查目前三個空間的狀態。它會告訴你：
    -   工作目錄裡有哪些檔案被修改了，但還沒放進暫存區？（工作室裡有哪些變動）
    -   暫存區裡有哪些變更，準備要被提交？（待展區裡有什麼）
    -   這是一個你每天會用幾十次的指令，它就像你的 Git 儀表板。
-   `git add <檔案名稱>`：將指定檔案的「變更」從工作目錄放入暫存區。注意，是放入「變更」，而不是整個檔案。
    -   例如，你修改了 `style.css` 的第10行，執行 `git add style.css`，就是把「對第10行的修改」這個動作放進了暫存區。
-   `git commit -m "你的提交訊息"`：將暫存區裡的所有變更，打包成一個新的版本快照（一個 Commit），並存入本地儲存庫。`-m` 後面的訊息至關重要，它是在為你的「箱子」貼標籤，說明這次提交做了什麼。一個好的訊息應該是清晰、簡潔的，例如 `feat: Add user login page` 或 `fix: Correct calculation error in checkout`。



### **第三部分：Git 的超能力 —— 分支與合併**

如果說三大空間是 Git 的基礎架構，那麼「分支」（Branching）就是 Git 的超能力，也是它遠勝於其他版本控制系統的關鍵。

**什麼是分支？**

回到我們寫小說的比喻。你寫完了前三章，這時你有一個大膽的想法：讓主角在第四章死掉，故事走向黑暗風格。但你又不確定這樣好不好，也許保持原來的陽光風格更好。

**沒有分支的情況：**
你要麼硬著頭皮改下去，改爛了就得手動慢慢改回來。要麼你複製整個專案資料夾，變成 `小說_黑暗版`，然後在裡面修改。這又回到了手動版本控制的混亂中。

**有了分支：**
在 Git 中，你的主要故事線在一個叫做 `main`（或 `master`）的分支上。當你有新想法時，你可以從 `main` 分支的當前位置，創建一個新的分支，比如叫做 `dark-ending`。

-   **比喻：創造一個平行時空。**
    `main` 分支是你的「主時空」。當你創建 `dark-ending` 分支時，你就像創造了一個平行時空。這個平行時空在被創造的那一刻，和主時空一模一樣。但是，接下來你在 `dark-ending` 分支（平行時空）裡做的任何修改——比如殺死主角、燒毀村莊——都**完全不會影響**到 `main` 分支（主時空）。

你可以隨時在兩個時空之間切換。今天在 `dark-ending` 裡寫黑暗結局，明天覺得沒靈感，就切換回 `main` 分支，繼續寫陽光快樂的第四章。兩個版本互不干擾，完美隔離。

**為什麼要用分支？**

1.  **無畏的實驗**：你可以隨意嘗試任何瘋狂的想法，不用擔心把主專案搞砸。如果實驗失敗，你只需要刪掉那個分支（摧毀那個平行時空），主時空毫髮無傷。
2.  **功能開發**：在團隊合作中，每個新功能都應該在一個獨立的分支上開發。A隊員開發「登入功能」分支，B隊員開發「購物車功能」分支，大家各自工作，互不影響。
3.  **Bug 修復**：線上產品突然出現一個緊急 Bug！你可以立刻從當前的正式版（`main` 分支）開一個 `hotfix-bug-123` 的分支，專心修復這個 Bug，測試通過後，再把它合併回 `main` 分支並上線。這期間，其他正在開發新功能的分支完全不受影響。

**合併（Merging）**

在 `dark-ending` 平行時空裡，你把黑暗結局寫完了，而且你覺得棒極了！你決定這就是你想要的最終版本。這時，你就需要把平行時空的變更，合併回主時空。這個過程就叫做「合併」（Merge）。

你切換回 `main` 分支，然後執行一個合併指令，告訴 Git：「把 `dark-ending` 分支上的所有變更，都應用到我現在所在的 `main` 分支上。」

Git 會智慧地將兩個分支的差異進行合併。大部分情況下，這個過程會自動順利完成。

**合併衝突（Merge Conflict）**

當然，有時空合併就會有衝突。

想像一下，在 `dark-ending` 分支裡，你把第三章的結尾改成了：「主角拔出了劍。」
同時，在你切換回 `main` 分支寫作時，你也把第三章的同一句話改成了：「主角轉身離開。」

當你試圖將 `dark-ending` 合併回 `main` 時，Git 就會陷入困惑。它看到同一個地方有兩種不同的修改，它不知道該聽哪個時空的。這就是「合併衝突」。

發生衝突時，Git 不會擅作主張。它會停下來，在衝突的檔案裡標記出衝突的地方，然後對你說：「嘿，人類，這裡有兩個版本，我不知道怎麼選，你來決定吧！」

你需要做的就是：
1.  打開那個衝突的檔案。
2.  你會看到類似 `<<<<<<< HEAD`、`=======`、`>>>>>>> dark-ending` 這樣的標記，它們分別包住了來自 `main` 分支和 `dark-ending` 分支的內容。
3.  你根據你的意願，手動編輯這段內容，決定最終要保留哪個版本，或者將兩者結合，然後刪掉 Git 添加的那些特殊標記。
4.  儲存檔案，然後再次使用 `git add` 和 `git commit` 來告訴 Git：「好了，衝突我已經解決了，你可以繼續合併了。」

雖然聽起來有點嚇人，但理解了原理後，解決合併衝突只是一個簡單的手動編輯過程。

#### **分支與合併的基礎指令**

-   `git branch`：列出所有本地分支。
-   `git branch <分支名稱>`：創建一個新的分支。
-   `git checkout <分支名稱>` (或新指令 `git switch <分支名稱>`)：切換到指定的分支。（**跳進平行時空**）
-   `git checkout -b <分支名稱>` (或新指令 `git switch -c <分支名稱>`)：創建並立即切換到新的分支。（**二合一快捷操作**）
-   `git merge <要合併過來的分支名稱>`：將指定分支的變更，合併到你「當前所在」的分支。


### **第四部分：Git 的協作宇宙 —— 與他人共事**

到目前為止，我們討論的都是在你自己的電腦上（本地）使用 Git。但 Git 最強大的地方在於協作。

**遠端儲存庫（Remote Repository）**

-   **這是什麼？** 一個位於網路伺服器上的 Git 儲存庫。最常見的服務就是 GitHub、GitLab 和 Bitbucket。
-   **比喻：中央圖書館。** 你電腦上的 `.git` 資料夾是你的「個人檔案室」，而遠端儲存庫則是大家共同認可的「中央圖書館」。你的所有工作都在個人檔案室裡完成和記錄，但最終的成果需要提交到中央圖書館，才能讓其他人看到和使用。同樣，你也需要定期從中央圖書館同步最新的資料，看看別人提交了哪些新成果。

**核心協作流程**

1.  **Clone（克隆）**：當你第一次參與一個專案時，你需要將遠端儲存庫（中央圖書館）完整地複製一份到你的本地電腦上。這個指令是 `git clone <遠端儲存庫的網址>`。
    -   這不只是下載最新檔案，而是把中央圖書館的**整個歷史**（所有提交快照）都複製了下來，建立了一個一模一樣的個人檔案室。

2.  **Pull（拉取）**：在你開始一天的工作之前，或者在你準備提交自己的變更之前，你都應該先從遠端儲存庫同步最新的變更，確保你的本地版本和遠端同步。這個指令是 `git pull`。
    -   **比喻：從中央圖書館同步最新檔案。** `git pull` 會檢查中央圖書館是否有你個人檔案室裡沒有的新「箱子」（Commits），如果有的話，就把它們拿回來，並自動與你當前的工作進行合併。

3.  **Push（推送）**：當你在本地完成了一個功能（通常是在一個獨立的分支上），並提交了數個 commits 之後，你就可以將你的這些新「箱子」推送到遠端儲存庫，與團隊分享。這個指令是 `git push`。
    -   **比喻：將你的新成果送到中央圖書館。** `git push` 會把你本地分支上的 commits 上傳到遠端儲存庫對應的分支上。

**一個標準的團隊合作工作流**

假設你要為專案新增一個「使用者個人資料頁面」：
1.  **`git pull`**：確保你本地的 `main` 分支是最新版本。
2.  **`git checkout -b feature/user-profile`**：從最新的 `main` 分支，創建並切換到一個名為 `feature/user-profile` 的新分支。分支名稱通常會有一個約定俗成的規範，例如 `feature/`、`fix/` 等，方便識別。
3.  **開始工作**：在這個新分支上，你開始撰寫程式碼、新增檔案。
4.  **`git add .`** 和 **`git commit -m "feat: Create basic user profile layout"`**：完成一部分工作後，就進行一次提交。一個功能可能會有好幾次提交，每次提交都應該是一個完整且有意義的步驟。
5.  **重複步驟 3 和 4**：直到整個功能開發完成。
6.  **`git push origin feature/user-profile`**：將你本地的 `feature/user-profile` 分支，連同上面的所有 commits，推送到遠端儲存庫（`origin` 是遠端儲存庫的預設別名）。
7.  **建立 Pull Request (PR) / Merge Request (MR)**：在 GitHub 或 GitLab 的網頁介面上，你會看到一個提示，讓你為剛剛推送的分支建立一個「合併請求」。這相當於你向團隊正式提出申請：「嘿，大家快來看，我完成了使用者個人資料頁面，這是我的程式碼，請幫我審查一下，如果沒問題，就請把它合併到 `main` 分支裡吧！」
8.  **程式碼審查 (Code Review)**：你的隊友會審查你的程式碼，可能會提出一些修改建議。
9.  **合併**：一旦審查通過，專案的維護者就會點擊按鈕，將你的 `feature/user-profile` 分支正式合併到 `main` 分支中。
10. **完成！** 你的貢獻已經成為主專案的一部分。其他隊友在下一次 `git pull` 時，就會把你的程式碼同步到他們各自的電腦上。

這個流程確保了主分支 (`main`) 永遠是穩定、可運作的，所有的開發和實驗都在獨立的分支上進行，通過團隊審查後才能合併，極大地提高了專案的品質和協作效率。


### **第五部分：實用技巧與補充概念**

掌握了以上觀念，你就已經理解了 Git 的 80%。剩下的就是一些讓你的工作更順暢的實用工具。

-   **`.gitignore` 檔案**
    -   你的專案中，總會有一些檔案是你**不希望**被 Git 追蹤的。例如：
        -   密碼、API 金鑰等敏感資訊。
        -   編譯產生的檔案（例如 `.exe`, `.class`）。
        -   作業系統自動產生的檔案（例如 macOS 的 `.DS_Store`）。
        -   日誌檔、暫存檔。
    -   你可以在專案的根目錄下建立一個名為 `.gitignore` 的純文字檔案，把這些不想追蹤的檔案或資料夾名稱寫進去，一行一個。Git 就會自動忽略它們，`git status` 裡再也看不到它們的蹤影。

-   **`git diff`**
    -   `git status` 告訴你哪些檔案被改了，而 `git diff` 則會告訴你**具體改了什麼內容**。
    -   `git diff`：比較 **工作目錄** 和 **暫存區** 的差異。
    -   `git diff --staged`：比較 **暫存區** 和 **本地儲存庫（最新一次 commit）** 的差異。

-   **`git log`**
    -   查看提交歷史的指令。
    -   `git log`：顯示詳細的歷史紀錄，包括 commit ID、作者、日期和提交訊息。
    -   `git log --oneline --graph --decorate`：一個非常實用的組合，用圖形化的方式簡潔地展示分支和合併的歷史。

-   **撤銷操作**
    -   **情況一：在工作目錄的修改還沒 `add`**
        -   如果你想放棄對某個檔案的修改，回到上次 commit 的狀態，使用 `git checkout -- <檔案名稱>`。**注意：這個操作是毀滅性的，你的修改會直接被覆蓋，無法找回！**
    -   **情況二：已經 `add` 到暫存區，但還沒 `commit`**
        -   如果你想把檔案從暫存區「拿回來」，但保留工作目錄的修改，使用 `git reset HEAD <檔案名稱>`。
    -   **情況三：已經 `commit` 了，但想修改最後一次的提交**
        -   如果你只是想修改最後一次的提交訊息，使用 `git commit --amend`。
        -   如果你想在最後一次提交中再增加一些修改，先 `git add` 那些修改，然後再執行 `git commit --amend`。


### **結語：Git 不只是一個工具，更是一種思維方式**

學習 Git 的過程，就像學習一門新的語言。一開始，你會覺得語法（指令）很陌生，規則（工作流）很繁瑣。但請務必堅持下去，因為它回饋給你的，遠遠不止於「備份檔案」這麼簡單。

-   它給了你一個**安全網**，讓你有信心去重構、去實驗、去創造，因為你知道任何時候你都可以回到過去。
-   它提供了一套**清晰的協作框架**，讓團隊合作從混亂的口頭溝通和檔案傳輸，變成有條不紊、權責分明的流程。
-   它為你的專案建立了一部**詳實的歷史傳記**。幾年後，當你想知道某段程式碼為何如此設計時，`git log` 和 `git blame` 會告訴你答案。

**給初學者的最後建議：**
1.  **動手實作**：在你的電腦上建立一個 `test-git` 資料夾，然後把這篇文章裡提到的所有指令都親手敲一遍。創建分支、修改檔案、製造衝突、解決衝突。親身經歷一遍，勝過閱讀十遍。
2.  **善用圖形化工具**：雖然指令列是 Git 的核心，但對於初學者來說，使用如 VS Code 的 Git 整合、SourceTree、GitKraken 等圖形化介面（GUI）工具，可以幫助你更直觀地理解三大空間和分支結構。
3.  **從個人專案開始**：先用 Git 來管理你自己的個人專案，哪怕只是一個筆記資料夾。當你習慣了「add -> commit」的節奏後，再去參與團隊專案。

Git 的學習曲線或許有些陡峭，但它絕對是你程式設計生涯、甚至任何數位創作生涯中，最值得投資的技能之一。它將把你從檔案管理的混亂中解放出來，讓你專注於真正重要的事情——創造。

### 附註
#### 📂 本地 Git 指令（Local）

| 指令                    | 說明           |
| --------------------- | ------------ |
| `git init`            | 初始化本地倉庫      |
| `git status`          | 查看目前變更狀態     |
| `git add`             | 將檔案加入暫存區     |
| `git commit -m "msg"` | 提交變更至本地歷史    |
| `git log`             | 查看提交紀錄       |
| `git diff`            | 比較尚未提交的變更    |
| `git branch`          | 建立/查看分支      |
| `git checkout`        | 切換分支或 commit |
| `git merge`           | 合併分支         |
| `git rebase`          | 變基整理提交歷史     |
| `git stash`           | 暫存未完成變更      |
| `git tag`             | 加上標籤（例如版本號）  |

✅ **這些指令只作用在你電腦本機的 Git 倉庫，完全不會連網。**



#### 🌐 遠端 GitHub 指令（Remote）

| 指令                            | 說明                        |
| ----------------------------- | ------------------------- |
| `git remote add origin <url>` | 設定遠端倉庫位置（例如 GitHub）       |
| `git fetch`                   | 從遠端取得更新，但不合併              |
| `git pull`                    | 從遠端抓取並合併（= fetch + merge） |
| `git push`                    | 將本地變更推送至遠端                |
| `git clone <url>`             | 複製整個遠端倉庫                  |
| `git push -u origin <branch>` | 新分支首次 push 並設定追蹤          |
| `git pull origin <branch>`    | 指定從哪個遠端分支拉取               |
| `git remote -v`               | 檢視遠端倉庫設定                  |

✅ **這些指令需要網路連線，且是與 GitHub 等遠端伺服器互動的操作。**