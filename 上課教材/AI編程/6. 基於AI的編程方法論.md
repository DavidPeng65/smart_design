基於AI的編程方法論
---

**(會議室內，晨光從窗戶灑落。Alex 的筆記型電腦開著，上面顯示著一些零散的 Python 腳本和 Gemini 的對話視窗，他眉頭微鎖。)**

**Alex:** 林顧問，感謝您今天特地來訪。我就開門見山了。我們團隊在導入 AI 輔助編寫 pyAEDT 自動化腳本時遇到了瓶頸。我們試著讓工程師直接對 AI 下指令，像是「幫我寫一個提取 DDR5 通道 S-parameter 的腳本」，但產出的程式碼品質非常不穩定。有時能用，有時漏洞百出，甚至會幻想出不存在的函式。團隊的抱怨是，花在跟 AI「吵架」和修改它程式碼上的時間，比自己從頭寫還多。我們是不是對 AI 的期待太高了？

**林顧問:** (微笑著點點頭) Alex，您的感受我完全理解。這不是您的期待太高，而是與 AI 協作的方式需要「工程化」。您遇到的問題，根源在於把 AI 當成了一個黑盒子般的「許願池」，而不是一個需要清晰藍圖來指導的「建築團隊」。我們需要的，不是一次性的「許願」，而是一套系統化的「引導方法」。

**Alex:** 引導方法？請您詳細說明。

**林顧問:** 當然。我們可以把這個方法的核心，看作是為每一個自動化任務，都建立一份「**AI 開發指導手冊**」，我習慣稱之為 `Prompt Blueprint`。這份手冊，就是一個詳細的 Markdown 文件，我們就叫它 `GEMINI.MD` 好了。它包含了三個核心部分：「**情境、規格、架構**」。我們以「**DDR5 SDD21 提取自動化**」這個任務為例，來一起草擬這份文件的 v1.0。

**(林顧問轉向白板，拿起筆開始勾勒文件的結構。)**

**林顧問:** 首先，是**第一部分：情境 (Context)**。我們要把專案的背景故事講清楚，讓 AI 進入狀況。

> **(白板上的 v1.0 內容)**
> * **任務情境:** 驗證伺服器主機板的 DDR5 DQ 通道，板材 Rogers RO4350B，16層板。目標信號為 `DDR_A_DQ0_P/N`，參考地為 `GND`。使用 Ansys 2025 的 HFSS 3D Layout 求解器，掃頻 DC-40GHz。

**林顧問:** 接著，**第二部分：規格 (Specification)**。我們要下達明確的技術合約，定義輸入輸出。

> **(白板上的 v1.0 內容)**
> * **主函數規格:** `extract_ddr_channel_sparam(aedb_path, signal_nets, ...)`
> * **輸入:** `.aedb` 路徑、信號 net name 列表...
> * **輸出:** 包含 S-parameter 的 CSV 檔案路徑、執行狀態的布林值。

**林顧問:** 最後，也是最重要的，**第三部分：架構 (Architecture)**。我們在動工前，先畫好建築藍圖。

> **(白板上的 v1.0 內容)**
> * **函數分解:** `setup_aedt_project`, `create_hfss_setup`, `assign_ports_to_nets`, `run_and_export_results`。
> * **測試考量:** 若輸入的 net name 不存在，程式應能拋出 `ValueError`。

**Alex:** (邊看邊點頭) 這套方法非常結構化，我完全理解。等於是我們先把所有思考工作都做完了，AI 負責體力活。但...林顧問，現實情況是，即使我們做到這樣，AI 產出的第一版程式碼，可能還是會有問題。比如，它可能沒考慮到效能。

**林顧問:** 問得太好了，Alex！這正是我要說的關鍵。您剛才描述的，是這套方法論的「第一天」。而它的真正威力，體現在「第二天」以及之後的每一天。您說的效能問題，我們來做個沙盤推演。您的工程師拿著這份 `v1.0` 的 Prompt，讓 AI 生成了 `script_v1.py`。執行後發現，結果正確，但模擬跑了整整5個小時。您的資深工程師一看，立刻就發現問題是「網格剖分 (Meshing) 策略太粗暴」。接下來，他該怎麼做？

**Alex:** 在我們過去的工作模式裡，他會嘆口氣，然後親自動手去修改那個 `script_v1.py` 的程式碼。

**林顧問:** (伸出食指搖了搖) 在我們的新方法論裡，他要做一個完全不同的動作。他要打開的，是那份 `GEMINI.MD` 檔案。我們要將這次的「學習經驗」記錄下來，讓這份藍圖「**演進**」。這就是**第四種方式：迭代式優化與回饋循環**。

**(林顧問在白板上，為 `GEMINI.MD` 增加了一個新的區塊。)**

**林顧問:** 他會把文件升級為 `v2.0`。首先，在文件末尾增加一個「**迭代日誌 (CHANGELOG)**」。

> **(白板上的 v2.0 新增內容)**
> * **第五部分：迭代與優化紀錄**
>     * **v1.0 -> v2.0 (2025-07-31):**
>         * **問題:** v1.0 產出的腳本模擬時間過長。
>         * **根本原因:** Prompt 中未定義網格剖分策略，AI 採用了低效的全模型加密。
>         * **決策:** 在架構中，對 `create_hfss_setup` 函數新增明確的效能要求。

**林顧問:** 記錄完日誌後，他再回到**第三部分：架構**，找到對應的函數，把新的要求「**注入**」進去。

> **(白板上的 v2.0 修改內容)**
> * **3.2 函數分解:**
>     * `create_hfss_setup(...)`
>         * **(V2 優化要求):** 在此函數中，網格剖分操作「必須」採用「Mesh on Selection」策略。只對 `signal_nets` 周圍 2mm 的範圍進行精細剖分。

**Alex:** (恍然大悟) 我懂了！**我們不是在修正程式碼，我們是在修正「產生程式碼的指令」！** 這樣一來，這次學到的教訓，就變成了這份藍圖的一部分，永久地保留下來了！

**林顧問:** 這就是「**知識沉澱**」！這份 `GEMINI.MD` 變成了一份活的文件。現在，我來介紹**第五種方式：提示詞管理與版本控制**。這份如此重要的文件，您會如何保管它？

**Alex:** 我會把它放到我們專案的 Git 儲存庫裡。

**林顧問:** 完全正確！當您的工程師完成 `v2.0` 的修改後，他會執行：
`git add GEMINI.MD`
`git commit -m "feat(DDR5_Sim): Optimize meshing strategy for performance"`
這個 commit 記錄了**為什麼**要改、改了**什麼**。這讓整個 AI 開發流程變得**可追溯、可複現**。這就是我所說的「**PromptOps**」。

**Alex:** 這太有啟發性了。這套方法論，結合了我們熟悉的軟體工程實踐，像是 Code Review 和 Git 版控，但應用的對象從程式碼轉移到了 Prompt。這解決了我對於流程無法標準化、知識無法傳承的擔憂。

**林顧問:** 是的。而且這還能走得更遠。這就是我想跟您分享的終極願景，也是我們討論的最後兩個進階策略：「**防禦性設計**」和「**系統整合**」。您可以要求在 `v3.0` 的 Prompt 中，加入對檔案不存在、net name 錯誤的 `try-except` 處理，這就是防禦性設計。當您透過這個流程，為不同的任務都打造出高度成熟的 Prompt 文件後，例如：
* `DDR5_SDD21_Prompt_v2.0.md`
* `PDN_Impedance_Prompt_v1.5.md`
* `EMI_Scan_Prompt_v1.2.md`

**林顧問:** (面向 Alex，語氣變得更加開闊) Alex，您的團隊下一個專案，將不再是寫單一的 SI/PI 腳本。而是去開發一個更高層次的「**自動化驗證協調器 (Automation Orchestrator)**」。這個協調器會讀取專案設定，自動從 Git 拉取最新、最穩定的 `.md` Prompt 藍圖，然後指揮 AI 依序執行，最終生成一份完整的、包含 SI、PI、EMI 的全方位驗證報告。

**Alex:** (深深吸了一口氣，眼神中充滿了對未來的想像) 從混亂的單點嘗試，到結構化的單任務藍圖，再到版本化、持續演進的知識庫，最後成為一個由無數個成熟藍圖所驅動的宏大自動化系統...。林顧問，您今天為我們描繪的，不只是一套技巧，而是一條清晰的技術演進路線圖。我們不再是 AI 的使用者，而是 AI 系統的設計者和管理者。

**林顧問:** 您總結得非常到位，Alex。這就是「**AI 系統架構師**」的角色。未來，工程師的核心價值，不再是記得多少 API，而在於能否設計出這樣精良、穩健、可擴展的「智慧藍圖」。

**(會議結束，Alex 闔上筆電，上面的 pyAEDT 腳本和 Gemini 對話視窗已經不再重要。他打開了一個新的 Markdown 檔案，鄭重地打下標題：「DDR5_SDD21_Prompt_v1.0.md」。他們的第一步，現在才真正開始。)
***