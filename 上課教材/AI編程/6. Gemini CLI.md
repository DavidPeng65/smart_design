## 使用 PyEDB 自動化 ANSYS EDB 的 PCB 堆疊管理

### ✅ **1. 角色與核心目標**

您是一位資深的 PCB 模擬自動化工程師。您的核心目標是利用 `pyedb`（ANSYS EDB Python API）程式庫，開發一套 Python 工作流程，以**自動化 PCB 堆疊（Stackup）資訊的匯出與匯入**。

此流程旨在解決以下痛點：
* **效率低下**：取代手動在 GUI 中逐層輸入參數的重複性工作。
* **易於出錯**：減少人工輸入錯誤的風險。
* **版本控制**：將複雜的堆疊設定存檔於易於管理的 Excel 表格中，方便追蹤與比較。
* **團隊協作**：讓不熟悉 ANSYS 工具的材料或佈局工程師也能透過 Excel 修改堆疊參數。

---

### 🧠 **2. 任務總覽**

請撰寫三支獨立但相互關聯的 Python 程式：
1.  **`export_stackup_to_excel.py`**: 從 `.brd` 檔案讀取設計，並將其完整的堆疊資訊匯出至格式化的 Excel 檔案。
2.  **`import_stackup_from_excel.py`**: 讀取上述 Excel 檔案，並將其中定義的參數更新回 AEDB 專案。
3.  **`test_excel_to_aedb.py`**: 建立一個自動化測試，驗證整個匯出-修改-匯入流程的正確性與可靠性。

---

### 📋 **3. 詳細任務需求**

#### **🔹 腳本 1: `export_stackup_to_excel.py` (匯出至 Excel)**

* **目的**: 建立一個可供人類閱讀和編輯的堆疊報告。
* **執行流程**:
    1.  接收一個 `.brd` 檔案路徑作為輸入。
    2.  使用 `edb = Edb(brd_path, edbversion='2024.1')` 初始化並建立一個 `.aedb` 專案。
    3.  遍歷堆疊中的每一層，並擷取下表所列的參數。
    4.  將數據寫入名為 `stackup_report.xlsx` 的 Excel 檔案。
* **Excel 輸出規格**:

| 欄位名稱 (Header)                 | 內容描述                                                              | 格式化規則                                                                                                    |
| --------------------------------- | --------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------- |
| `Layer Name`                      | 層的名稱。                                                            | -                                                                                                             |
| `Layer Type`                      | 層的類型 (e.g., `signal`, `dielectric`)。                             | -                                                                                                             |
| `Thickness`                       | 層的厚度。                                                            | 允許使用者透過參數指定輸出單位為 `mil` 或 `mm`。                                       -                                                                                                             |
| `Dielectric Constant (Dk)`        | 材料的介電常數 ($D_k$)。                                                | 若 `Layer Type` 為 `signal` 或 `conductor`，此欄位應為**空值**，且儲存格背景應**填滿黑色**。              |
| `Loss Tangent (Df)`               | 材料的損耗角正切 ($D_f$)。                                              | 若 `Layer Type` 為 `signal` 或 `conductor`，此欄位應為**空值**，且儲存格背景應**填滿黑色**。              |
| `Conductivity`                    | 導電率 (S/m)。                                                        | 若 `Layer Type` 為 `dielectric`，此欄位應為**空值**，且儲存格背景應**填滿黑色**。                       |
| `Etching Factor`                  | 蝕刻因子。                                                            | 若 `Layer Type` 為 `dielectric`，此欄位應為**空值**，且儲存格背景應**填滿黑色**。如果讀取值為 0，則顯示 0。 |
| `Top/Bottom/Side Nodule Radius (µm)` | Huray 粗糙度模型的**節點半徑**，單位為微米 ($µm$)。分三列。       | 同 `Etching Factor`。                                                                                         |
| `Top/Bottom/Side Surface Ratio`   | Huray 粗糙度模型的**表面粗糙係數**。分三列。                          | 同 `Etching Factor`。                                                                                         |

---

#### **🔹 腳本 2: `import_stackup_from_excel.py` (從 Excel 匯入)**

* **目的**: 根據修改後的 Excel 報告，自動更新 AEDB 專案。
* **執行流程**:
    1.  接收一個現有的 `.aedb` 專案路徑和 `stackup_report.xlsx` 路徑作為輸入。
    2.  讀取 Excel 表格中的數據。
    3.  對每一層（以 `Layer Name` 為索引）執行以下更新邏輯：
        * **厚度**: 根據 Excel 中的 `Thickness` 和 `Thickness Unit` 欄位，將值轉換為公尺（meter）後更新 `layer.thickness`。
        * **材料 (Dielectric)**:
            a. 根據該層的 $D_k$ 和 $D_f$ 值，產生一個標準化的材料名稱，格式為 `m_<dk>_<df>` (例如 `m_4.1_0.02`)。
            b. 檢查此材料是否存在於 AEDB 專案中。
            c. 若不存在，則使用 `edb.materials.add_dielectric_material()` 建立新材料。
            d. 將該層的材料指定為此材料。
        * **材料 (Conductor)**:
            a. 直接使用 `edb.materials.add_conductor_material()` 建立或指定材料。
        * **蝕刻**: 如果 Excel 中的 `Etching Factor` 不為 0，則更新 `layer.etch_factor`。
        * **粗糙度**:
            a. 檢查該層所有六個 Huray 參數（半徑與係數），只要有**任何一個不為 0**，就必須啟用該層的粗糙度設定。
            b. 啟用後 (`layer.roughness_enabled = True`)，分別對 "top", "bottom", "side" 呼叫 `layer.assign_roughness_model()`，並傳入 Excel 中對應的 `nodule_radius` 和 `surface_ratio`。
            c. 如果所有 Huray 參數皆為 0，則不啟用粗糙度設定。
        * **填充材料 (Fill Material)**:
            a. 此邏輯在所有層的主要參數更新完畢後執行。
            b. 找出所有 `signal` 層並按其在堆疊中的物理順序排序。
            c. 設訊號層總數為 $n$。
            d. **前 $n/2$ 層**（上半部）：其 `fill_material` 設定為其**正上方**相鄰介電層的材料。
            e. **後 $n/2$ 層**（下半部）：其 `fill_material` 設定為其**正下方**相鄰介電層的材料。
    4.  將所有變更儲存到一個**新的** AEDB 專案中（例如 `updated_stackup.aedb`），以避免覆蓋原始檔案。

---

#### **🔹 腳本 3: `test_excel_to_aedb.py` (自動化驗證)**

* **目的**: 確保整個工作流程的準確無誤。
* **執行流程**:
    1.  **設定 (Setup)**: 執行 `export_stackup_to_excel.py` 以產生一個基準的 `stackup_report.xlsx`。
    2.  **修改 (Modify)**:
        a. 使用 `pandas` 載入 Excel 檔案。
        b. **隨機**選擇一個 `dielectric` 層和一個 `signal` 層。
        c. 對這些層的參數進行確定性的修改，例如：厚度 +10 mil, $D_k$ +0.2, `Surface Ratio` +0.5。
        d. 將修改後的 DataFrame 存回 `stackup_report.xlsx`。
    3.  **執行 (Execute)**: 執行 `import_stackup_from_excel.py`，它將讀取修改後的 Excel 並生成 `updated_stackup.aedb`。
    4.  **驗證 (Verify)**:
        a. 使用 `pyedb` 重新載入 `updated_stackup.aedb`。
        b. 讀取先前被修改過的層的屬性。
        c. 使用 `assert` 語句和 `math.isclose()` 進行精確比對，確認厚度、材料屬性 ($D_k$, $D_f$)、粗糙度等參數是否已成功更新為新值。
        d. 在控制台或日誌中清晰地輸出每個比對項目的成功或失敗訊息。
    5.  **清理 (Teardown)**: 測試結束後，自動刪除所有產生的臨時檔案與目錄（`.aedb` 目錄, `.xlsx`, `.log` 等），以保持工作區乾淨。

---

### 🖥️ **4. 開發與執行環境**

* **相依性**: AI 執行環境中已安裝 `pyedb`, `pandas`, `xlsxwriter`。
* **輸入檔案**: 當前目錄下已提供 `Galileo_G87173_204.brd` 作為測試資料。
* **程式碼風格**:
    * 大量使用日誌 (`logging`) 記錄關鍵步驟、警告與錯誤。
    * 撰寫清晰的函式與 docstrings。
    * 在主程式區塊 (`if __name__ == "__main__":`) 中定義檔案路徑與主函式呼叫，使其易於執行與修改。
* **API 參考**: 優先使用以下已驗證過的 API，如 `edb.stackup.layers`, `edb.materials.add_*_material`, `layer.assign_roughness_model`, `edb.save_edb_as` 等。

```Python
### 驗證過可以用的的API，請優先參考
from pyedb import Edb

#%% 讀取
brd_path = r"D:\OneDrive - ANSYS, Inc\GitHub\stackup_editor\Galileo_G87173_204.brd"

edb = Edb(brd_path, edbversion='2024.1')
for layer_name, layer in edb.stackup.layers.items():
    print(layer.type)
    print(layer_name)
    print(layer.thickness) #meter
    print(layer.top_hallhuray_nodule_radius)
    print(layer.top_hallhuray_surface_ratio)
    print(layer.bottom_hallhuray_nodule_radius)
    print(layer.bottom_hallhuray_surface_ratio)
    print(layer.side_hallhuray_nodule_radius)
    print(layer.side_hallhuray_surface_ratio)
    

    
    print(layer.etch_factor)
    material = edb.materials.materials[layer.material]
    print(material.permittivity)
    print(material.loss_tangent)
    print(material.conductivity)
    
    
edb.close_edb()

#%% 編輯
edb = Edb(edb_path, edbversion='2024.1')

# metal material for signal layers, m_conductivity
m1 = edb.materials.add_conductor_material('cond1', conductivity=5e7)

# dielectric material for dielectric layers, m_dk_df
m2 = edb.materials.add_dielectric_material('dielectric1', permittivity=3, dielectric_loss_tangent=0.03)

for layer_name, layer in edb.stackup.layers.items():
    layer.thickness = 0.003 #meter
    layer.etch_factor = 2
    layer.roughness_enabled = True
    layer.fill_material = m2.name
	layer.material = m1.name
	
    # support "top", "bottom", "side"
    layer.assign_roughness_model(model_type="huray",
                                 huray_radius="0.5um",
                                 huray_surface_ratio="2.9",
                                 apply_on_surface="top",)
edb.save_edb_as(new_edb_path)
```
